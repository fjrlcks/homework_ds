# RSA 알고리즘
RSA는 두 개의 키를 사용한다. 여기서 키란 메시지를 열고 잠그는 상수(constant)를 의미한다. 일반적으로 많은 공개키 알고리즘의 공개키(public key)는 모두에게 알려져 있으며 메시지를 암호화(encrypt)하는데 쓰이며, 암호화된 메시지는 개인키(private key)를 가진 자만이 복호화(decrypt)하여 열어볼 수 있다. 하지만 RSA 공개키 알고리즘은 이러한 제약조건이 없다. 즉 개인키로 암호화하여 공개키로 복호화할 수도 있다.

공개키 알고리즘은 누구나 어떤 메시지를 암호화할 수 있지만, 그것을 해독하여 열람할 수 있는 사람은 개인키를 지닌 단 한 사람만이 존재한다는 점에서 대칭키 알고리즘과 차이를 가진다.

RSA는 소인수 분해의 난해함에 기반하여, 공개키만을 가지고는 개인키를 쉽게 짐작할 수 없도록 디자인되어 있다.

보다 이해하기 쉬운 예를 들자면, A라는 사람에게 B라는 사람이 메시지를 전하고자 할 때 B는 A의 열린 자물쇠를 들고 와 그의 메시지를 봉인(공개키 암호화 과정에 해당)하고, 그런 다음 A에게 전해 주면, 자물쇠의 열쇠(개인키에 해당)를 가지고 있는 A가 그 메시지를 열어보는(개인키 복호화 과정에 해당) 식이 된다. 중간에 그 메시지를 가로채는 사람은 그 열쇠를 가지고 있지 않으므로 메시지를 열람할 수 없다.

메시지와 공개키 모두를 알 수 있다면 변조된 메시지를 보낼 수 있기 때문에, 실제로는 수신측의 공개키만을 사용하여 암호화하는 경우는 드물다. 송수신 양측의 키쌍을 사용하는 방법으로는 A의 개인키로 암호화 -> B의 공개키로 암호화 한 메시지를 전달하고 복호화 과정은 B의 개인키로 복호화 -> A의 공개키로 복호화로 구성된 방식이 일반적이다. RSA의 디자인 상, 그 열쇠(개인키에 해당)는 자물쇠의 형태(공개키에 해당)만 보고서는 쉽게 제작할 수가 없게 되어 있다.

키의 생성
A와 B가 보안이 보장되어 있지 않은 환경에서 서로 비밀 메시지를 주고 받고 싶다고 가정하자. B가 A에게 메시지를 전달하기 위해서는 A의 공개키가 필요하다. A는 아래와 같은 방법을 통해 그만의 공개키와 개인키를 제작한다.

p 와 q 라고 하는 두 개의 서로 다른 ({\displaystyle p\neq q}p\neq q) 소수를 고른다.

두 수를 곱하여 {\displaystyle N=pq\,}N=pq\, 을 찾는다.
{\displaystyle \varphi (N)=(p-1)(q-1)\,}\varphi (N)=(p-1)(q-1)\, 를 구한다.
{\displaystyle \varphi (N)}\varphi (N) 보단 작고, {\displaystyle \varphi (N)}\varphi (N)와 서로소인 정수 e를 찾는다.
확장된 유클리드 호제법을 이용하여 {\displaystyle d\times e}d\times e를 {\displaystyle \varphi (N)}\varphi (N)로 나누었을 때 나머지가 1인 정수 d를 구한다. ({\displaystyle de\equiv 1{\pmod {\varphi (N)}}}de\equiv 1{\pmod  {\varphi (N)}})
A의 공개키는 위에서 구한 두 개의 숫자로 이루어진 <N, e>이고, 개인키는 <N, d>이다. A는 <N, e>만을 B에게 공개하고, B는 이 공개키를 사용하여 자신의 메시지를 암호화하게 된다. 여기서 p와 q의 보안은 매우 중요하다. 이를 가지고 d와 e의 계산이 가능하기 때문이다. 그리하여 공개키와 개인키가 생성이 된 후에는 이 두 숫자를 지워버리는 것이 안전하다.

암호화
B가 M이란 메시지를 A에게 보내고 싶다고 하자. 일단 B는 이 M을 N보다 작은 숫자 m으로 변환한다. (이 변환법(padding scheme)은 A에게도 미리 알려져 있어야 한다. 이를테면, 메시지를 토막내어 하나의 메시지가 일정 수의 비트를 넘지 않게 하는 방법이 있다. 하지만 실제로는 이중보안을 위해 더욱 복잡한 변환법이 사용된다.) 그리고 B는 A의 공개키 <N, e>를 획득하고, 다음과 같이 c를 계산한다.

{\displaystyle c=m^{e}\mod {N}}c=m^{e}\mod {N}
그리고 이 c를 A에게 보낸다.

복호화
A는 암호화된 메시지 c를 B에게서 건네받았고, N과 d를 알고 있다. 다음 식을 통해 m을 찾는다.

{\displaystyle m=c^{d}\mod {N}}m=c^{d}\mod {N}
위에서 설명하였듯 m을 가지고 A는 M을 찾아낼 수 있는 방법을 알고 있다.

증명
이 해독법이 가능한 이유는 다음과 같다.

{\displaystyle c^{d}\equiv (m^{e})^{d}\equiv m^{ed}\equiv m^{k(p-1)(q-1)+1}\equiv m{\pmod {N}}}c^{d}\equiv (m^{e})^{d}\equiv m^{{ed}}\equiv m^{{k(p-1)(q-1)+1}}\equiv m{\pmod  {N}}.
마지막 등식이 성립하는 이유는 다음과 같다. 위의 식에서 mod N 대신 mod p 사용하여 풀이했을 때,

{\displaystyle m^{k(p-1)(q-1)+1}\equiv (m^{p-1})^{k(q-1)}m{\pmod {p}}}m^{{k(p-1)(q-1)+1}}\equiv (m^{{p-1}})^{{k(q-1)}}m{\pmod  {p}}
가 된다. p가 소수이므로, m이 p의 배수가 아니라면 서로소이므로 페르마의 소정리를 다음 식과 같이 적용할 수 있다. 만약 m이 p의 배수라면 양변이 p의 배수이므로 0과 동치가 되어 역시 다음 식이 성립된다.

{\displaystyle (m^{p-1})^{k(q-1)}m\equiv 1^{k(q-1)}m\equiv m{\pmod {p}}}(m^{{p-1}})^{{k(q-1)}}m\equiv 1^{{k(q-1)}}m\equiv m{\pmod  {p}}
mod q를 사용하여도 똑같은 풀이가 가능하다. N = pq 이므로, mod N에도 같은 식이 성립하게 된다
